"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _keywords = require('../parser/tokenizer/keywords');
var _types = require('../parser/tokenizer/types');

var _elideImportEquals = require('../util/elideImportEquals'); var _elideImportEquals2 = _interopRequireDefault(_elideImportEquals);



var _getDeclarationInfo = require('../util/getDeclarationInfo'); var _getDeclarationInfo2 = _interopRequireDefault(_getDeclarationInfo);
var _getImportExportSpecifierInfo = require('../util/getImportExportSpecifierInfo'); var _getImportExportSpecifierInfo2 = _interopRequireDefault(_getImportExportSpecifierInfo);
var _getNonTypeIdentifiers = require('../util/getNonTypeIdentifiers');
var _isExportFrom = require('../util/isExportFrom'); var _isExportFrom2 = _interopRequireDefault(_isExportFrom);
var _removeMaybeImportAttributes = require('../util/removeMaybeImportAttributes');
var _shouldElideDefaultExport = require('../util/shouldElideDefaultExport'); var _shouldElideDefaultExport2 = _interopRequireDefault(_shouldElideDefaultExport);

var _Transformer = require('./Transformer'); var _Transformer2 = _interopRequireDefault(_Transformer);

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
 class ESMImportTransformer extends _Transformer2.default {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? _getNonTypeIdentifiers.getNonTypeIdentifiers.call(void 0, tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? _getDeclarationInfo2.default.call(void 0, tokens)
        : _getDeclarationInfo.EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(_types.TokenType._import, _types.TokenType.name, _types.TokenType.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(_types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(_types.TokenType._export, _types.TokenType._import, _types.TokenType.name, _types.TokenType.name, _types.TokenType.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(_types.TokenType._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(_types.TokenType._export, _types.TokenType.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(_types.TokenType._export, _types.TokenType.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(_types.TokenType.braceL)) {
        while (!this.tokens.matches1(_types.TokenType.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(_types.TokenType._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(_keywords.ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        _removeMaybeImportAttributes.removeMaybeImportAttributes.call(void 0, this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      _elideImportEquals2.default.call(void 0, this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(_types.TokenType._import, _types.TokenType.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(_types.TokenType.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      _removeMaybeImportAttributes.removeMaybeImportAttributes.call(void 0, this.tokens);
      if (this.tokens.matches1(_types.TokenType.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(_types.TokenType._import);
    if (
      this.tokens.matchesContextual(_keywords.ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, _types.TokenType.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, _keywords.ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(_types.TokenType.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(_keywords.ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, _keywords.ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(_types.TokenType.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(_types.TokenType.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(_types.TokenType.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to add it back if necessary.
          needsComma = true;
          this.tokens.removeToken();
        }
      }
    }

    if (this.tokens.matches1(_types.TokenType.star)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierNameAtRelativeIndex(2))) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        this.tokens.removeToken();
      } else {
        if (needsComma) {
          this.tokens.appendCode(",");
        }
        foundNonTypeImport = true;
        this.tokens.copyExpectedToken(_types.TokenType.star);
        this.tokens.copyExpectedToken(_types.TokenType.name);
        this.tokens.copyExpectedToken(_types.TokenType.name);
      }
    } else if (this.tokens.matches1(_types.TokenType.braceL)) {
      if (needsComma) {
        this.tokens.appendCode(",");
      }
      this.tokens.copyToken();
      while (!this.tokens.matches1(_types.TokenType.braceR)) {
        foundAnyNamedImport = true;
        const specifierInfo = _getImportExportSpecifierInfo2.default.call(void 0, this.tokens);
        if (
          specifierInfo.isType ||
          this.shouldAutomaticallyElideImportedName(specifierInfo.rightName)
        ) {
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.removeToken();
          }
          if (this.tokens.matches1(_types.TokenType.comma)) {
            this.tokens.removeToken();
          }
        } else {
          foundNonTypeImport = true;
          while (this.tokens.currentIndex() < specifierInfo.endIndex) {
            this.tokens.copyToken();
          }
          if (this.tokens.matches1(_types.TokenType.comma)) {
            this.tokens.copyToken();
          }
        }
      }
      this.tokens.copyExpectedToken(_types.TokenType.braceR);
    }

    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }

   shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   processExportDefault() {
    if (
      _shouldElideDefaultExport2.default.call(void 0, 
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export defa6 Q b 5 D X o U y L s G F X . 2 . 4   ze@   vk   €         IsBackgroundt      lf  èW ValièW Valihbin P                        àÿÿÿvk ‚   ø#     - HashIDatàÿÿÿvk     2     6 RankSizeàÿÿÿvk    (%      FileSizeàÿÿÿvk   €        E IsPinned    À Øÿÿÿvk
    Q     E ExpiredMapo . 1 èÿÿÿlf   Down  Uplo0   vk	    P       SessionIdenVecto   €ä Øÿÿÿ                                    Øÿÿÿvk   €ê         ExpiredMapSize  àÿÿÿvk    `        tcpOpen àÿÿÿvk          n peerHttpàÿÿÿvk    Ž      peerHttpÐÿÿÿvk   €         GroupConnectionCountÆ±ÏÐÿÿÿvk   €        ¿þHttpConnectionCount ckgrÐÿÿÿvk   €          InternetConnectionCount Ðÿÿÿvk   €        tyLanConnectionCount  p' Ðÿÿÿvk   €         LinkLocalConnectionCountØÿÿÿvk	   €         PeerCountileId  àÿÿÿvk R    æ     alFileIdN Øÿÿÿvk	   €          CacheHost   vk Øÿÿÿvk    8      psCachedBytes vk Øÿÿÿ{ŸÿÿÿþÿÿÿÿÿÿÿÿÿÿÀ               € (   vk
   €€        ExpiredMapityizeàÿÿÿvk ‚   `e      HashID	 àÿÿÿvk     D     ilRank å Ðÿÿÿvk   €        U GroupConnectionCountes ðÿÿÿÐ™
    (K àÿÿÿvk    ¨Z      tcpOpen øÿÿÿ T xÿÿÿà     ˜† @ Ø†  ‡ € ` h   øŽ À ˆà  â ¸ô @ø hø ¸  å ¨P @Q (¹   ÈQ øQ (R XR ˆR ¸R  S (S Ê æ xÿÿÿf a c f 9 5 d 1 d 1 e 8 1 0 d 9 4 5 b 3 8 1 9 3 2 5 3 e a 0 0 4 c a 2 b 6 f f 2 0 1 9 6 8 5 d a 0 0 8 6 b b 0 1 b 3 5 e 6 6 7 3   æ àþÿÿC : \ W i n d o w s \ S e r v i c e P r o f i l e s \ N e t w o r k S e r v i c e \ A p p D a t a \ L o c a l \ M i c r o s o f t \ W i n d o w s \ D e l i v e r y O p t i m i z a t i o n \ C a c h e \ d 4 9 b 6 1 d 4 3 1 0 f e 0 a 9 4 6 7 d c 7 f f d 0 6 b c a 7 a 3 a b f c c e d   àÿÿÿvk   €       ª StatusÈ Ðÿÿÿvk    h       DownloadDurationMsecsø    size°ÿÿÿJ R q 7 5 A 6 O 0 U G Q o S 5 9 . 4 0 . 3 . 1 . 0 . 0 . 1 1 . 2 . 1 8   ð/ Èÿÿÿ                                                   i`   nk  OýŽ©ÇÚ   ¸²         ÿÿÿÿÿÿÿÿ    ÿÿÿÿÿÿÿÿÿÿÿÿ                       UploadStatstsnal¨ÿÿÿnk  ÇT§WÅÚ   (Y         ÿÿÿÿÿÿÿÿ   @Ä ˜   ÿÿÿÿ                     RawBytesØÿÿÿvk
    xk     E ExpiredMapheckIn   vk Øÿÿÿvk   €€ô     Ž UploadForSecs#í àÿÿÿvk   €          IsPinnedØÿÿÿvk    ðæ      ExpireAtTimeFT èÿÿÿSu;ø=¡E·ObføNèù    Ðÿÿÿvk   €         GroupConnectionCount  Ðÿÿÿvk   €         HttpConnectionCount ˆY  ÿÿÿnk  8Ù½ŸÄÚ   P%        €m ÿÿÿÿ    ÿÿÿÿ˜   ÿÿÿÿ                      DownloadStats_0 Øÿÿÿvk
 &   pÆ      CallerNameilek Øÿÿÿvk	   €        AtPeerCounte  ÈL àÿÿÿvk Ö  ÈJ      CdnURL àÿÿÿvk   €        Upload àÿÿÿvk    °X      PeerId    ØY Øÿÿÿvk
   ˜ò     2 WorkingDir6 5 - Øÿÿÿvk	    Z     C SessionId D 6 2 èÿÿÿŒ"{ìùŒzO¾ŒyC¦—Â8T ðÿÿÿÀuQ    Sizeàÿÿÿvk   €        StatustyàþÿÿC : \ W i n d o w s \ S e r v i c e P r o f i l e s \ N e t w o r k S e r v i c e \ A p p D a t a \ L o c a l \ M i c r o s o f t \ W i n d o w s \ D e l i v e r y O p t i m i z a t i o n \ C a c h e \ 7 5 8 2 d 0 6 0 e c e a 4 5 a b b e 6 8 1 b 8 a 9 e a 3 1 e c e 3 0 3 2 1 a 6 6   Èÿÿÿvk   €        î CacheServerConnectionCount‚ l ® Ðÿÿÿvk   €         InternetConnectionCount Ðÿÿÿvk   €         LanConnectionCount ˆY   nk  ´n£ÇÚ    ¿         ÿÿÿÿÿÿÿÿ    ÿÿÿÿÿÿÿÿÿÿÿÿ                       UploadStats æ è X   { a f a b 5 c 3 6 - a 8 2 4 - 4 4 a 1 - 8 9 7 3 - c c 8 4 5 9 8 9 6 c 9 0 }   les_0     vk ‚    e     ` HashIDb     vk    8^     - Rank1 e (   vk   €€:	     8 UploadForSecs 6 è   Š˜o¹ˆ%G¨qšÈ—7    Ð   vk   €        ilIsPinned(   vk    ðì     f ExpireAtTimeFTì ˆ   vk Ô  ¨e      CdnURL h   vk   €          ExpireAtOverride@   vk   €          Uploadze    vk    0T      FileSizeàÿÿÿvk    ¸^      Have8 àÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿP pP àÿÿÿvk   €¨        HaveSizeØÿÿÿvk
    w      ExpiredMap ^ Ðÿÿÿvk   €         LinkLocalConnectionCountØÿÿÿvk	   €         CacheHostÆ X Øÿÿÿvk    l      CachedBytesplayN   ee6fèÿÿÿlf  A Downxq Uploàÿÿÿvk    Pw      tcpOpen àÿÿÿvk    ØA      peerHttphbin €  @                      àÿÿÿvk    †      tcpOpen