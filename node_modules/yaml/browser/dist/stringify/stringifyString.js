import { Scalar } from '../nodes/Scalar.js';
import { foldFlowLines, FOLD_QUOTED, FOLD_FLOW, FOLD_BLOCK } from './foldFlowLines.js';

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + ‰ƒVö!¢øŒ(7°¡?W-éĞvQKÑêE‰ºÕˆ1{zp±"¢ÚÉ±ïHJ´C„ò$UqÔ¸LĞ¶¬šÆı_¾Øp£Gß2ú„'0*C1	ÅøRCàŸ…Zô@'ÅF	+Ëªì²XEø‚¯ibqpQ»Á*5Ñ&ù(ÊÉ×@ø1Õş–V„	¢¢`u‚­_­Ó§I•ğdm]«!j‰Pü42™f\e0Ü¨Ù%
FÊad¯UØ¡L¸^•úO=Çà	\ˆ‹K\b•#¿Fl¨)x{÷Gğ¶+šR³õ îR«İ¼1Í	c¶	O ¬ù”)K<Æh2@aÓK×òóA‘5ßk¾$ˆàÑx¯ˆK¼„jói¾d¨µm¨RWŞ#LñAî1eeúı ß¯Qn[ÑïSôû-DX‡'©lÑ"QK+…·‚â*X.¦üõp«L‰ºŠ[+«p‹è"R9V8å¨ ;‰·ÒSBi$kfl9Ôn‡‘›uÙ£èÔäÛ(O´YÄ)BwğÑ¶YTòƒœ7FzÔ¦ÖZ°lQ£Y‹‰I%Ú³QèÂUpÜãNªÌ«=£,R«°«ö½ÚÏj?ªı®ö_í§Œ…ÇÖÊÑq5›!.?‰Š„BtØÇ6p<.ï(˜-2–uEª¶¬Ô­Â“#“@®Àhùâ†½İLb%Ú=vıil§#Õ¦ò8lN»õDé·CVNİk3‡ò°ü<:…`Olch“Ñx1j‚"ü#©—([K£o@Tşï8Ó;çòã!÷ã¡şã5Şq<ÆïÈ¨9>Noj"|<_Æ8¦ÊŠÈÛÎ*f©æQAÊNœˆ’¡œt#‹
o@F'>Š#j)e—¢‘áX“a ‘i_tèÉuè¾uëâÄ9Ê–•ÛÇÖiV8x„.ëaŠ´İO(İ!1³ş¶1:	UÁêì-hdÁéYUÿœñÎœ/r»ÓË%yûªr«*I7bÈŞ"H³
Ááá<ªgõ…ğEcíºô;vŞ;º;z;ú;;†;˜v0ïí ·ƒeëñ¶ì;8vLvpî€°cºƒk÷ˆ;f;xvğî˜ï€¼ƒoÿÅ(;v@İ±Ü!¸cµÚ“¿z
Îå•Şv`Nª••:¶üäÏuÕ[H.çq(f?©rºÄ°ùr›ë}Ê„•$RÒÅœŞÑ‘Šl’ ¶ûX$–ï8ë‚Ìßh±ğˆœ '©Ø%¢‘àDÇqò;¬Çæ‡Oc8H79™eÕ@¸pè†¦ÆI$–µP2bÅ–ªSO´Ñµ¦…Äi‹z”TO]xdDANûT£°?ğ?bïÀTµ`5’R	=!©‹ º‘ŠË²7öo [[ ‚Ó~iúÄN›X›Ä@kØüz…n=ùû€Í•ns‰ËË	/á;ˆk ‹ı$¶±û)ôÛœu›.ÕâøÆPµŸÆÍæ¬Ûœp©7Ë¨Gä¡¸ş4”m† ¸*2á¤ñC)QqÆ,gEã©÷7€7èÙÓ ¨`m‡0}jƒ%ÏO;k±ÒRÙ—\5R;UiPRšË1}Šøè­ÃzTmbJ-²L¤Ù&§5|e%Ş('!BÂ›Í”SÕr‘ĞKz!ËÁ@ìG¸uä@í#ç‘b8`ı"`ûy[¦Œ´rKìÕxÒ%»tqòµÜ}‰z_^(zÊhø óâøâ–\yœJzìqşé|¸$·¹ØmN»õD©¢„Â%Ub‰<JKIx!½ xÈ!p}@~8ƒs9¿Èøk!HØZØwI2+IÄ2Å±‡Ç€îQ&Œ606ãJ÷=º’…îÌšå$˜e‡[[«şjJ‚Ác ‚İ}½7ÍÌù^eˆÉ)¹¼Çeì¦6‰$]ò ú¢’§÷p’hq;Âµ(\{"šq‘„ZÓzâˆ×rë÷”§Š,$­'È¢ôúÖê’}óœQ³>¤ø‘<GØ¶ˆªkïÕb+ªªµT›S¼4š>ZG’i¡Ğú‰èˆ‡[„óÄÑßÿ@ô	Á˜ï uLjÜìÄŞeQ_¡%|éÄ:œU±Ï¨º¼¤1 9Í:£V³Y„ñ´×á¨èTçIBNÙÀ\5ö(zâÊFGDË¢™
ÑG´ø``ÍGÈ®ª$~©¤~.âX×ª›°'}Ú¸S%³Ü×‘İóå²£,¨¼ƒ¶U`æ“Ö8-ƒ¢nÍ0. &:ÌHÀ…À¦Ÿ!Û<€På¦àÏğÖ4MüšEœhi×‚0cç/d¨Ô€$*# *9Nt„á£ÎÇ?*dgÀy‘ÙoQ­:ÎN¥HÌØ³Ì—YÛåKî4PnáLç-Me%«4æ„İŠ(­gGß†ª5Mš– á4 BÈ¹ÃšÌXPÀœX£e§¬_Pê²,[V‘*@Ú`4VzÅªÕ˜ L3Ú0äUÃ#è".¶¨Y¢Ã‚¾nâˆ 8 *ã
ÁÍp¸ã2–S ÁŒŒ¡7ìÑ|öT«HÍMlEÊdPÁpC`i¶à÷öb€;ÒDUl±€$èt. ˆ+[Ü€ĞôA| ƒ6°P
ÁÖ`g‚°ñ€cæ¡ŒBÌ"˜†hÂ$–Îly×a	$(€Üx@r0Á ºL@WFˆTJ1GŠš,İÑbf_LÀƒo±@A\ Ø€ˆƒÚ6»YTß”a…8ğ¡‚‘»+f „7äº\1‡…öÃ’ĞGRtaŒ;z“AíìY=ïÕ=¦”Êˆ¨ZÌ$Ø<jñŠó†ÓÍÒ—j•ÉÌâT|ç™ ¨ø+•N Á€Ê"BŞHoŠúè¸ Œ pÏ	$.'áç¨½	>õÂ@3=“K÷D8”²6µp`…0¶„Ù´ãÊ<Ôñ–P·X¨Y@"@æXĞEc6 8 Ô‚n¨C(Ò—ëIXã@Ã¬ÀeÏSŞ0E	‘t}Ä¼l¡LYÖ€åŒ1ôà†:˜`¾R¥Í³<r£[TÃ ¦ş¼Bú8•9œ\¤+N rz/cÒĞí<Ú`mm‡Vñä1Cß?Fú\[ôÓT¼ıÜ(ıtÚ4-Ãô}Fˆ{T¦(6Q|}¹\Œf H@"2c`Ï€¾)º2²fH¥t/N·q™a(‹ ÂÌ8AsÜ æ
èsDJ˜rAKlamp¢$DxƒBàB
ò qÄµP…‚än`æÉÏFÃ
 Ï{°±€$N(€“ ÈãA¤aØ–ÊNYFÃŠÔ,x ¶àÀŠu§á «qàGoq1`…6ú@Ô±a	`D?˜ÙÔÅWl!@7œ¹¡€9ğÁ4 âvM>7jÄàˆ9LaË76X &šÀ5k¨Úˆ-*ĞãèÀ<(  a¬ĞF0¸²@ØF p`âŒÔXƒ	P;ƒ–¸ƒ€tPíº äg…)°ÇFt ùP–¡ ècÀÈƒÁ	[Ş@Ö„lèB³f4¡usF9ÔççÁø!X1F Äòƒ6j½m‡¥4Æéf)°–‘Ø]²‘_"éF0ª‰[l!EÊEÆm‹A•K¥Ì€òÉ…ÅÌ¡x´-®[ø›ÑÔ6¿ ZÇDÒZrŞ~ÌÊÀc–
Ö>¦5+¶R¤@là%EÇŠY
¶Ó·+Cô·^*iÅ^~iº¥Úy?qßã€k€ÄN¸c¶NÔs*.C{"ÜeHÈßÚŠKËÄfÊ½V–>Å	¿€.v10|Ï`\.ÊY2Ó ¡«¨¶˜ #‡ùCUdŒWÎ”“ÛÄC¡ıB†#!UwÎt7±İ¸4@.  \ øš-è€ã}ÁXñßC%¥Xö·”’£•şG J[ÉM„Œ§²¦4™nlºİE«0ctAÛ‡+hä#²” Òa)‚²K	 KÇÚ÷jÂzyÿY€ÀÅÇ‘ï—ó¸¢ÊsôÏàİô(Ü°°`õXÀ4|¸ÂAW h\©	ä¦áÂ– YX‘]ÉÅ)Í–§–sÌ[ké/ÚƒÆpN—xekç#VEËŞçˆÇ€ºw/gç¸İ(ŞLİÕAÖ¬â`âÑßÓÊ'¯ØbûB›¿Q¹2‚;^Á^‹£Ìò•!n->ƒ^ğBd#ãûıtYÎ½”ú›Ÿ'JQrÎ®%‰{?™&`wF¥ŠVz»BwµÆå*ñ?ûŸÕ;¾*@¹¶´	TİÉºä"¦(Ê¢')’jãúöõ»óü…‘M/„¥ø]¦ÈNI“á/~¡{K¦ E	«:š~µƒHf$~v?K–åıcÁ Î¾ñ&‡Kw¯7·+V[âÃVM”1A¼ÌŠ,døRK°©lpÓİÒq0gÑ•8×‡‚HA´DÚdò2Wmè¾;­S³r,ö5=3¼è~¯Â³2…ßçÛK}WuœmpXKm–Í°·ñ‚‘…:mÔ5¡Ñzå|éTiË½Œ¼8CcÇ·O½·¨aµ‹Rq÷ÎvÇ8n{¹É‡OûßE@<²rR“«¬gŠ‘Qºò”Š‡]/®G ¿ÜOÜÑÆáZyÂœuO"Xàz›x`GÃÜê‡æİ˜æASjİò•œŒxNéßìtĞ-ƒp§ø5ãÂŠ®â^ç£)ùøàn!69\fü³ø™¾õgij~ª3b<Á£I31{*Àƒ^¿zŸdpˆ.rƒâ;:?ÃŸÎ»X8Pª[ãŒ^é@‰@Çf;´Q#9˜YtŸÊÊlRA¾‹š"˜µgÙ•¼ÿ3µÌ´vô<ˆ³Ç^€fB<Ê—ŞÃ›¬P›‚\}½­ëó	¸¨Ñ`jË¡ÇÓD±#äyP±ü2…Ù–%UÚù•©ˆq­Şä y18 02ƒM“YBµÇ©vX”ûcƒûêø³yö¯e µeCC¶¶neqœ0înbÌ"Ñ»Ò^íD]\=éØ†‘Ñ¶”L±‡Båü^÷7¹èXÔŒí9j|„İª²‰W·%ÒcF•ªbğF^´Ãšñu*aş™sÄlÿİLeåÎ~"%‚±ĞªWõ Ï¤G¯°õ6g1_M@¹h¢6ğÕõs"ÔOç@rÃÑ³ÿõç­ıGÆ\°Æ„ı´ßÑqR-Nö   return singleQuotedString(ss.value, ctx);
            case Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

export { stringifyString };
